/**
 * \page tutorial1 Tutorial 1. Getting started
 *
 * In this tutorial you will get acquainted with the most basic functionality of the library. The goal of this
 * exercise is to generate a ready-to-use \f$(t, m, s)\f$-net.
 *
 *
 *
 *
 *
 * \section tutorial1_1 1. Preparations
 *
 * We assume that before reading this tutorial you already downloaded the library and unpacked its files. If you
 * didn't and you don't know how to do this, read the instructions at [How to download](@ref download) page. We
 * also assume your decent knowledge of C++.
 *
 * \note These tutorials only cover the features of the latest \b stable version of the library.
 *
 * Let us now create a sample project for the purposes of this tutorial. You may do this however you prefer:
 * manually or with the help of your most favourive IDE. Hereafter we assume that our sample project
 * has the following file structure.
 *
 * \snippet tutorial1.txt file_structure
 *
 * File <tt>main.cpp</tt> was created manually and it is currently empty.
 *
 *
 *
 *
 *
 * \section tutorial1_2 2. Create a generator
 *
 * Let us now open and edit <tt>main.cpp</tt> file of our sample program. There, in order to use our library, we
 * first need to include it. One can do this with the help of the line
 *
 * \snippet tutorial1.txt include_line
 *
 * The functionality of our library is completely stored within a sole namespace called \ref tms. In particular,
 * the generators of Niederreiter's \f$(t, m, s)\f$-nets in base \f$2\f$ will be represented as the objects of class
 * \ref tms::Niederreiter. Each generator has the parameters \f$t\f$, \f$m\f$ and \f$s\f$ as invariants meaning
 * that if at some moment of time you need to change their values, you'll have to create a new generator. These
 * parameters have the following meaning:
 *
 * * \f$t\f$ : this non-negative integer parameter signifies the quality of points' dispersion within the unit cube.
 * More precisely, the less its quantity is, the lower is the discrepancy of the net. Minimal possible value of
 * \f$t\f$ increases with the growth of dimension;
 * * \f$m\f$ : this non-negative integer parameter signifies the binary logarithm of maximal number \f$M\f$ of points
 * the generator can generate, i.e., \f$m = \log_2 M\f$. Please remember that \f$M\f$ must always be a power of \f$2\f$.
 * Minimal possible value of \f$m\f$ is \f$t\f$ and, hence, it increases with the growth of dimension as well;
 * * \f$s\f$ : positive integer dimension of the unit cube that we wish to fill with net's points.
 *
 * If you want to find out mathematically rigorous description of parameter \f$t\f$, check out the sources from
 * [Recommended literature](@ref literature). However, if you don't want to go deep into the theory, you shall not
 * despair, since our generator is capable of automatic selection of the best (i.e., the lowest) possible \f$t\f$
 * for each particular case. Having this, you may just forget about its existence.
 *
 * Let us now write a program that saturates a two-dimesional unit cube (i.e., a square with the length of each
 * edge being equal to \f$1\f$) with, say, \f$20\f$ quasirandom points. Here, \f$s = 2\f$, however, since \f$M\f$
 * must always be a power of \f$2\f$, we have to choose \f$M\f$ such that it is a power of \f$2\f$ and it is greater
 * than \f$20\f$. Let us consider the least possible such value, namely, \f$M = 32\f$ and, hence, \f$m = \log_2 32 = 5\f$.
 * Knowing this, we may finally create a new generator with the help of the following constructor.
 *
 * \snippet tutorial1.txt class_constructor
 *
 * Here \c UIntType is an unsigned integral type that has a bit capacity of at least \f$m\f$, \c nbits shall be
 * replaced with \f$m\f$ and \c dim shall be replaced with \f$s\f$. Having this said, we may write the following
 * piece of code.
 *
 * \snippet tutorial1.txt creation_of_generator
 *
 * Thus, \c my_generator is a generator of Niederreiter's \f$(t, m, s)\f$-nets which is capable of construction of
 * at most \f$32\f$ quasirandom points within two-dimensional unit cube.
 *
 *
 *
 *
 *
 * \section tutorial1_3 3. Check the parameters of generator
 *
 * Let us now quickly check the parameters of our generator. To do this, we can utilise three corresponding functions:
 * \c get_t, \c get_m and \c get_s.
 *
 * \snippet tutorial1.txt param_check
 *
 * The expected output is:
 *
 * \snippet tutorial1.txt param_check_output
 *
 * As we see, we were able to reach the value \f$t = 0\f$ which is the lowest possible ever. You may spend a couple of
 * minutes of your pastime on checking how the automatically chosen value of \f$t\f$ changes with the growth of \f$s\f$.
 *
 *
 *
 *
 *
 * \section tutorial1_4 4. Generating points
 *
 * Let us finally generate some points! To do this we are going to use the
 *
 * \snippet tutorial1.txt generate_method
 *
 * method. Its only argument \c pos specifies the ordinal number of the point we wish to generate. Since we want to get
 * not a single point but \f$20\f$ points at once, we should wrap the call of this method in a loop.
 *
 * \snippet tutorial1.txt generate_loop
 *
 * If you compile this code, you will see that it is still quite useless. Let us add the output of generated points to
 * finally be able to see their coordinates!
 *
 * \snippet tutorial1.txt generate_cout
 *
 * The expected output is:
 *
 * \snippet tutorial1.txt generate_cout_output
 *
 * However, <b>this is not a</b> \f$(t, m, s)\f$<b>-net</b>! This is just a set of \f$20\f$ quasirandom points obtained
 * with the help of \f$(t, m, s)\f$-nets generator!
 *
 * \note The result of generator work will be a \f$(t, m, s)\f$-net if:
 * 1. generated points have consecutive ordinal indices (\c pos)
 * 2. the number of generated points is a power of \f$2\f$ (say, \f$N\f$ where \f$N \le M\f$) and
 * 3. \f$N\f$ divides the ordinal index of the first point in this sequence.
 *
 * Let us then get a real \f$(t, m, s)\f$-net by cutting the number of generated points from \f$20\f$ to \f$16\f$. The
 * first and the third conditions have already been met (you may check this yourself).
 *
 * \snippet tutorial1.txt generate_net
 *
 * The expected output is:
 *
 * \snippet tutorial1.txt generate_net_output
 *
 * The parameters of resulting net can be calculated as follows:
 *
 * * \f$t\f$ equals \f$t\f$ of generator;
 * * \f$m\f$ equals \f$\log_2 N\f$ (hence, \f$m\f$ of a net may be less or equal to the \f$m\f$ of generator);
 * * \f$s\f$ equals \f$s\f$ of generator.
 *
 * Thus, we have obtained a \f$(0, 4, 2)\f$-net with the help of \f$(0, 5, 2)\f$-nets generator. This is a regular practice.
 * By reducing the number of generated points even more we may get \f$(0, 3, 2)\f$-, \f$(0, 2, 2)\f$-, \f$(0, 1, 2)\f$- and
 * \f$(0, 0, 2)\f$-net but we will never be able to get a \f$(0, 6, 2)\f$-net because in this tutorial our generator is only
 * capable of generating \f$2^5=32\f$ distinct points and \f$(0, 6, 2)\f$-net has to contain \f$2^6=64\f$ points.
 *
 * Let us finally visualise our net with the help of a thirdparty plotter (feature is not included into the library).
 *
 * \image html tutorial1_Step4_1.jpg
 */