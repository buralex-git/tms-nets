ИНСТРУКЦИЯ
==========




## Содержание

  * [Введение](#введение)
  * [Ветви репозитория](#ветви-репозитория)
  * [Технические требования](#технические-требования)
  * [Загрузка](#загрузка)
    * [Через git](#через-git)
    * [Через ZIP-архив](#через-zip-архив)
  * [Использование генератора](#использование-генератора)
    * [Описание структуры библиотеки](#описание-структуры-библиотеки)
    * [Описание класса `Niederreiter`](#описание-класса-niederreiter)
    * [Включение файлов в Вашу программу](#включение-файлов-в-вашу-программу)
    * [Примеры](#примеры)
  * [Тестирование](#тестирование)
    * [Описание тестов](#описание-тестов)
    * [Пределы применимости тестов](#пределы-применимости-тестов)
    * [Автоматическое тестирование](#автоматическое-тестирование)
    * [Сборка автоматического тестера с использованием CMake](#сборка-автоматического-тестера-с-использованием-cmake)
    * [Включение тестов в Вашу программу](#включение-тестов-в-вашу-программу)
    * [Уровни вербозности](#уровни-вербозности)
  * [Для дальнейшей разработки](#для-дальнейшей-разработки)
    * [Документация](#документация)
    * [Рекомендуемая литература](#рекомендуемая-литература)




## Введение

Данный репозиторий содержит в себе реализацию генератора участков (t, s)-последовательностей с основанием 2, созданного на основе алгоритма, предложенного Гаральдом Нидеррайтером в 1987 году в работе "Low-Discrepancy and Low-Dispersion Sequences". (t, s)-последовательности представляют собой удобный инструмент построения (t, m, s)-сетей — дискретного множества точек, равномерно распределённых по *n*-мерному единичному кубу. Подробнее о (t, s)-последовательностях и (t, m, s)-сетях — в ресурсах, указанных в [рекомендуемой литературе](#рекомендуемая-литература).

[^ наверх ^](#содержание)




## Ветви репозитория

  * **master** — главная ветвь; в ней располагается последняя стабильная версия проекта;
  * **development** — ветвь, содержащая самые актуальные наработки;
  * **gh-pages** — техническая ветвь, хранящая в себе файлы документации.

Объединение **gh-pages** с другими ветвями, а также самостоятельное изменение её содержимого не допускается.

[^ наверх ^](#содержание)




## Технические требования

Для работы генератора необходимо иметь:

  * компилятор, поддерживающий C++17;
  * 64-битный процессор с 2 и более ядрами.

[^ наверх ^](#содержание)




## Загрузка


#### Через git

Исполните команду

    git clone --single-branch --branch master https://github.com/jointpoints/tms-nets

[^ наверх ^](#содержание)


#### Через ZIP-архив

  1. Скачайте архив (кнопка **Clone or download**) [отсюда](https://github.com/jointpoints/tms-nets);
  2. Распакуйте архив в некоторую папку.

[^ наверх ^](#содержание)




## Использование генератора


#### Описание структуры библиотеки

Функционал данной библиотеки заключён в единственное пространство имён `sequences`, содержащее в себе все необходимые для работы определения. Пользователям рекомендуется знать о следующих компонентах пространства имён `sequences`:

  * `Niederreiter` — непосредственно класс генератора, подробнее о его использовании написано ниже в этом разделе;
  * `Real` — тип вещественных чисел с плавающей точкой;
  * `Point` — тип точки в *n*-мерном пространстве с компонентами типа `Real`;
  * `Polynom` — класс многочленов над полем **F₂**, подробнее о его использовании написано в [источнике](https://github.com/irreducible-polynoms/irrpoly/).

[^ наверх ^](#содержание)


#### Описание класса `Niederreiter`

Генератор последовательностей представлен шаблонным классом `sequences::Niederreiter<typename UIntType, unsigned int NBITS>`, где

  * `UIntType` — тип целочисленных переменных, который следует использовать в процессе генерации для хранения промежуточных результатов расчётов;
  * `NBITS` — число доступных бит в `UIntType` для хранения промежуточных результатов расчётов, **максимальное значение** — `sizeof(UIntType) * 8`.

(t, s)-последовательности периодичны. В нашей реализации период последовательности равен `2^NBITS`, поэтому чем больше уникальных точек необходимо сгенерировать, тем большее значение `NBITS` и, как следствие, тем более объёмный тип `UIntType` необходимо указывать.

Сигнатуры конструкторов:

1.

    Niederreiter(BasicInt const dim, bool const in_parallel)

  * `dim` — размерность пространства, единичный куб внутри которого необходимо заполнить;
  * `in_parallel` — указывает, следует ли генерировать неприводимые многочлены последовательно (`false`) или параллельно (`true`); **значение по умолчанию** — `false`.

Этот конструктор позволяет генерировать максимально плотно находящиеся друг к другу точки.

2.

    Niederreiter(std::vector<BasicInt> const &degrees_of_irred)

  * `degrees_of_irred` — вектор, задающий степени, которые следует использовать при генерации неприводимых многочленов; для *i*-й компоненты `degrees_of_irred.size()`-мерного пространства будет сгенерирован многочлен `degrees_of_irred[i-1]`-й степени.

Этот конструктор следует использовать, если требуется вручную настроить плотность точек по каждой компоненте. Чем выше степень *i*-го многочлена, тем менее плотно по *i*-ой компоненте распределены точки. Первый конструктор минимизирует все используемые степени, что позволяет добиться наилучшего результата по данному показателю.

3.

    Niederreiter(std::vector<Polynom> const &polynomials)

  * `polynomials` — вектор неприводимых многочленов над **F₂**, которые следует использовать при генерации (t, s)-последовательности; для *i*-й компоненты `polynomials.size()`-мерного пространства будет использован `polynomials[i-1]`-ый многочлен.

Этот конструктор следует использовать, если требуется вручную настроить плотность по каждой компоненте. В отличие от второго конструктора, который сам генерирует многочлены необходимой степени, данный конструктор требует их явного задания.

[^ наверх ^](#содержание)


#### Включение файлов в Вашу программу

При написании программ, использующих данный генератор, потребуются файлы из папки `include`.

В своём исходном коде пропишите строку

    #include "<your/path/to/our/files/>include/niederreiter2.hpp"

[^ наверх ^](#содержание)


#### Примеры

###### Пример 1. Простейший способ использования

Участок кода ниже генерирует и выводит первые 10 точек (t, s)-последовательности в трёхмерном пространстве.

    uint32_t dim    = 3;
    uint32_t amount = 10;
    sequences::Niederreiter<uint64_t, 64>   generator(dim);
    sequences::Point                        tmp_point;
    for (uint32_t i = 0; i < amount; ++i)
    {
        tmp_point = generator.get_point_real(i); // генерирует i-ую точку последовательности
        for (uint32_t j = 0; j < dim; ++j)
            std::cout << tmp_point[j] << '\t';
        std::cout << '\n';
    }

Вывод программы:

    0       0       0
    0.5     0.5     0.75
    0.75    0.25    0.3125
    0.25    0.75    0.5625
    0.375   0.375   0.875
    0.875   0.875   0.125
    0.625   0.125   0.6875
    0.125   0.625   0.4375
    0.1875  0.3125  0.515625
    0.6875  0.8125  0.265625

В скором времени будет добавлено больше примеров, раскрывающих весь функционал класса генератора.

[^ наверх ^](#содержание)




## Тестирование


#### Описание тестов

На данный момент реализованы тесты:

1.

    const bool niederreiter_check_definition(sequences::Niederreiter<UIntType, NBITS> *generator, uint8_t m)

Этот тест проверяет, являются ли `2^m` точек, рассчитанных генератором `generator`, (t, m, s)-сетью в классическом смысле Нидеррайтера. Тест может давать ложноположительные результаты, если генерируемые точки не уникальны.

2.

    const bool niederreiter_check_uniqueness(sequences::Niederreiter<UIntType, NBITS> *generator, uint8_t m)

Этот тест проверяет, являются ли `2^m` точек, рассчитанных генератором `generator`, покомпонентно уникальными.

Все тесты возвращают `true` при успешном прохождении и `false` при неуспешном.

[^ наверх ^](#содержание)


#### Пределы применимости тестов

Реализованные тесты оптимально расходают ресурсы памяти компьютера, поэтому ограничения относительно несущественные:

  * В общем случае не рекомендуется при тестировании использовать значения `NBITS`, превышающие `32`;
  * Тест `niederreiter_check_definition` работает только при значениях `NBITS`, не превышающих `63`.

[^ наверх ^](#содержание)


#### Автоматическое тестирование

Файл `tests/main.cpp` содержит автоматический тестер, генерирующий 100 случайных тестовых случаев.

[^ наверх ^](#содержание)


#### Сборка автоматического тестера с использованием CMake

Для сборки автоматического тестера можно воспользоваться утилитой CMake версии 3.8 или выше. Для сборки необходимо в командной строке перейти в папку с проектом и выполнить следующие команды:

    mkdir build
    cd build
    cmake .. -G "MinGW Makefiles"
    mingw32-make

После успешного выполнения в папке `build/test` будет находиться `test.exe`. Обратите внимание на то, что данный пример подразумевает использование компилятора MinGWw64. При использовании иного компилятора впишите после ключа `-G` вместо `MinGW Makefiles` формат Make-файлов, соответствующий Вашему компилятору.

[^ наверх ^](#содержание)


#### Включение тестов в Вашу программу

Для собственного использования тестов понадобятся папки `include` и `tests`.

В своём исходном коде вместо

    #include "<your/path/to/our/files/>include/niederreiter2.hpp"

пропишите строку

    #include "<your/path/to/our/files/>tests/tests.hpp"

[^ наверх ^](#содержание)


#### Уровни вербозности

Все реализованные тесты поддерживают пять уровней вербозности:

  * `0` - Никакой вывод не производится.
  * `1` - Выводится название теста и результат его выполнения (`+` или `-`).
  * `2` - Выводится название теста, результат его выполнения, а также расчётные параметры *t*, *m* и *s* (t, m, s)-сети (для `niederreiter_check_definition`), либо число покомпонентно уникальных точек (для `niederreiter_check_uniqueness`).
  * `3` - Выводится детальная информация о результатах теста, включая все найденные ошибки в работе генератора.
  * `4` - Выводится детальная информация и о процессе работы, и о результатах теста.

Задать желаемый уровень вербозности можно через макрос `VERBOSITY_LEVEL`, определить который нужно до включения файла `tests/tests.hpp`. По умолчанию уровень вербозности равен нулю.

[^ наверх ^](#содержание)




## Для дальнейшей разработки


#### Документация

Документация к стабильной версии программы доступна [здесь](https://jointpoints.github.io/tms-nets/) (на английском языке),
генерируется автоматически с помощью утилиты Doxygen при каждом изменении в ветви **master**. Для полного понимания номенклатуры и алгоритма рекомендуется ознакомиться с литературой из списка ниже.

[^ наверх ^](#содержание)


#### Рекомендуемая литература

  1. Harald Niederreiter "Low-Discrepancy and Low-Dispersion Sequences"
  2. Harald Niederreiter "Random Number Generation and Quasi-Monte Carlo Methods" (особенно глава 4)
  3. Paul Brately, Bennett L. Fox, Harald Niederreiter "Implementation and Tests of Low-Discrepancy Sequences"

[^ наверх ^](#содержание)
